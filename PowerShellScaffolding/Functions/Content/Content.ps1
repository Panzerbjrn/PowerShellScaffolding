$PSDContent = "#
# Module manifest for module 'PowerShellScaffolding'
#
# Generated by: Lars Panzerbjørn
#
# Generated on: 20/06/2019
#

@{
	# Script module or binary module file associated with this manifest.
	RootModule = `'$($ModuleName).psm1`'

	# Version number of this module.
	ModuleVersion = '1.0'

	# ID used to uniquely identify this module
	GUID = `'$((New-GUID).guid)`'

	# Author of this module
	Author = '$($Author)'

	# Company or vendor of this module
	CompanyName = '$($Company)'

	# Copyright statement for this module
	Copyright = '(c) 2019 $($Author). All rights reserved.'

	# Description of the functionality provided by this module
	Description = 'Module that will comtain scaffolding for a new module structure. This will include various template files to get started quickly.'

	# Minimum version of the Windows PowerShell engine required by this module
	PowerShellVersion = '5.0'

	# Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.
	FunctionsToExport = '*'

	# Cmdlets to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no cmdlets to export.
	CmdletsToExport = '*'

	# Variables to export from this module
	VariablesToExport = '*'

	# Aliases to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no aliases to export.
	AliasesToExport = '*'

	# Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.
	PrivateData = @{
		PSData = @{
			# Tags applied to this module. These help with module discovery in online galleries.
			Tags = @()
		} # End of PSData hashtable
	} # End of PrivateData hashtable
}"

$PSMContent = "#region Script Header
#	Thought for the day: $($TFTD)
#	NAME: $($ModuleName).psm1
#	AUTHOR: $($Author)
#	CONTACT: $($Email) / GitHub: $($GitHub) / Twitter: $($Twitter)
#	DATE: $($Date)
#	VERSION: 0.1 - $($Date) - Module Created with Create-NewModuleStructure by Lars Panzerbjørn
#
#	SYNOPSIS:
#
#
#	DESCRIPTION:
#	$($Description)
#
#	REQUIREMENTS:
#
#endregion Script Header

#Requires -Version 4.0

`[CmdletBinding`(PositionalBinding=`$false`)`]
param`(`)

Write-Verbose `$PSScriptRoot

#Get Functions and Helpers function definition files.
`$Functions	= @( Get-ChildItem -Path `$PSScriptRoot\Functions\*.ps1 -ErrorAction SilentlyContinue )
`$Helpers = @( Get-ChildItem -Path `$PSScriptRoot\Helpers\*.ps1 -ErrorAction SilentlyContinue )

#Dot source the files
ForEach (`$Import in @(`$Functions + `$Helpers))
{
	Try
	{
		. `$Import.Fullname
	}
	Catch
	{
		Write-Error -Message `"Failed to Import function `$(`$Import.Fullname): `$_`"
	}
}

Export-ModuleMember -Function `$Functions.Basename
"

$AboutHelpContentenGB = "TOPIC
		about_$($ModuleName)

SHORT DESCRIPTION
		$($Description)

LONG DESCRIPTION
		Default: A detailed, full description of the subject or purpose of the module.

EXAMPLES
		Default: Examples of how to use the module or how the subject feature works in practice.

KEYWORDS
		Default: Terms or titles on which you might expect your users to search for the information in this topic.

SEE ALSO
		Default: Text-only references for further reading. Hyperlinks cannot work in the Windows PowerShell console.
"

$PowerShellTemplateDoFunction = "##From https://docs.microsoft.com/en-us/previous-versions/technet-magazine/hh360993(v=msdn.10)
Function Do-Something
{
<#
	.SYNOPSIS
		Describe the function here

	.DESCRIPTION
		Describe the function in more detail

	.EXAMPLE
		Give an example of how to use it

	.EXAMPLE
		Give another example of how to use it

	.PARAMETER ComputerName
		The Computer name to query. Just one.

	.PARAMETER LogName
		The name of a file to write failed Computer names to. Defaults to errors.txt.

	.INPUTS
		Input is from command line or called from a script.

	.OUTPUTS
		This will output the logfile.

	.NOTES
		Version:			0.1
		Author:				Lars Panzerbjørn
		Creation Date:		2020.05.12
		Purpose/Change: Initial script development
#>
	[CmdletBinding(SupportsShouldProcess=`$True,ConfirmImpact='Low')]
	param
	(
		[Parameter(Mandatory,
			ValueFromPipeline=`$True,
			ValueFromPipelineByPropertyName=`$True,
			HelpMessage='What Computer name would you like to target?')]
		[Alias('host')]
		[ValidateLength(3,30)]
		[string[]]`$ComputerName,

		[string]`$Logname = 'errors.txt'
	)

	BEGIN
	{
		Write-Verbose `"Beginning `$(`$MyInvocation.Mycommand)`"
		Write-Verbose `"Deleting `$Logname`"
		Remove-Item `$LogName -ErrorActionSilentlyContinue
	}

	PROCESS
	{
		Write-Verbose `"Processing `$(`$MyInvocation.Mycommand)`"

		ForEach (`$Computer in `$ComputerName) {
			Write-Verbose `"Processing `$Computer`"
			IF (`$pscmdlet.ShouldProcess(`$Computer)) {
				# use `$Computer here
			}
		}
	}
	END
	{
		Write-Verbose `"Ending `$(`$MyInvocation.Mycommand)`"
	}
}"

$PowerShellTemplateGetFunction = "##From https://docs.microsoft.com/en-us/previous-versions/technet-magazine/hh360993(v=msdn.10)
Function Get-Something
{
<#
	.SYNOPSIS
		Describe the function here

	.DESCRIPTION
		Describe the function in more detail

	.EXAMPLE
		Give an example of how to use it

	.EXAMPLE
		Give another example of how to use it

	.PARAMETER ComputerName
		The Computer name to query. Just one.

	.PARAMETER LogName
		The name of a file to write failed Computer names to. Defaults to errors.txt.

	.INPUTS
		Input is from command line or called from a script.

	.OUTPUTS
		This will output the logfile.

	.NOTES
		Version:			0.1
		Author:				Lars Panzerbjørn
		Creation Date:		2020.05.12
		Purpose/Change: Initial script development
#>
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory=`$True,
			ValueFromPipeline=`$True,
			ValueFromPipelineByPropertyName=`$True,
			HelpMessage='What Computer name would you like to target?')]
		[Alias('host')]
		[ValidateLength(3,30)]
		[string[]]`$ComputerName,

		[string]`$LogName='Errors.txt'
	)

	BEGIN
	{
		Write-Verbose `"Beginning `$(`$MyInvocation.Mycommand)`"
		Write-Verbose `"Deleting `$LogName`"
		Remove-Item `$LogName -ErrorActionSilentlyContinue
	}

	PROCESS
	{
		Write-Verbose `"Processing `$(`$MyInvocation.Mycommand)`"

		ForEach (`$Computer in `$ComputerName) {
			Write-Verbose `"Processing `$Computer`"
			# use `$Computer to target a single Computer

			# create a hashtable with your output info
			`$Info = @{
				'info1'=`$value1;
				'info2'=`$value2;
				'info3'=`$value3;
				'info4'=`$value4
			}
			Write-Output (New-Object -Typename PSObject -Property `$Info)
		}
	}
	END
	{
		Write-Verbose `"Ending `$(`$MyInvocation.Mycommand)`"
	}
}"

$PowerShellTemplateVerbNoun = "##From https://docs.microsoft.com/en-us/previous-versions/technet-magazine/hh360993(v=msdn.10)
Function Verb-Noun
{
<#
	.SYNOPSIS

	.DESCRIPTION

	.EXAMPLE

	.PARAMETER

	.INPUTS

	.OUTPUTS

	.NOTES
#>
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory,
			ValueFromPipeline=`$True,
			ValueFromPipelineByPropertyName=`$True,
			HelpMessage='What?')]
		[Alias('alias')]
		[ValidateLength(3,30)]
		[ValidateNotNullOrEmpty()]
		[string[]]`$ComputerName
	)

	BEGIN
	{
		Write-Verbose `"Beginning `$(`$MyInvocation.Mycommand)`"
	}

	PROCESS
	{
		Write-Verbose `"Processing `$(`$MyInvocation.Mycommand)`"
	}
	END
	{
		Write-Verbose `"Ending `$(`$MyInvocation.Mycommand)`"
	}
}"

$ModuleTest = "`$ProjectRoot = Resolve-Path `"`$PSScriptRoot\..`"
`$ModuleRoot = Resolve-Path `"`$ProjectRoot\*.psm1`"
`$ModuleName = Split-Path `$ModuleRoot -Leaf

Describe `"General project validation: `$ModuleName`" {
	`$Scripts = Get-ChildItem `$ProjectRoot -Include *.ps1,*.psm1,*.psd1 -Exclude *WiP.ps1 -Recurse

	# TestCases are splatted to the script so we need hashtables
	`$TestCase = `$Scripts | Foreach-Object {@{file=`$_}}
	It `"Script <file> should be valid powershell`" -TestCases `$TestCase {
		param(`$File)

		`$File.Fullname | Should Exist

		`$Contents = Get-Content -Path `$File.Fullname -ErrorAction Stop
		`$Errors = `$null
		`$null = [System.Management.Automation.PSParser]::Tokenize(`$Contents, [ref]`$Errors)
		`$Errors.Count | Should Be 0
	}

	It `"Module '`$ModuleName' can import cleanly`" {
		{Import-Module `$ModuleRoot -force } | Should Not Throw
	}
}"